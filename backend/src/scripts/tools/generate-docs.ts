import { readFileSync, writeFileSync, mkdirSync } from "fs";
import { join, dirname } from "path";

interface CategorizedScript {
    path: string;
    filename: string;
    category: string;
    subcategory: string;
    purpose_description: string;
    key_functions: string[];
    dependencies_external: string[];
    dependencies_internal: string[];
    has_error_handling: boolean;
    lines_of_code: number;
}

function generateScriptEntry(script: CategorizedScript): string {
    const runCommand = script.path.includes("backend/src")
        ? `bun run backend/src/scripts/${script.filename}`
        : script.path.includes("backend")
            ? `bun run backend/scripts/${script.filename}`
            : `bun run scripts/${script.filename}`;

    return `
### โ๏ธ ${script.filename}
**File Path:** \`${script.path}\`  
**Category:** ${script.category} โ’ ${script.subcategory}  
**Lines:** ${script.lines_of_code} | **Error Handling:** ${script.has_error_handling ? "โ… Yes" : "โ ๏ธ No"}

**Purpose:**  
${script.purpose_description}

**Key Functions:**
${script.key_functions.length > 0 ? script.key_functions.map((fn) => `- \`${fn}()\``).join("\n") : "- N/A"}

**Dependencies:**
- External: ${script.dependencies_external.length > 0 ? script.dependencies_external.join(", ") : "None"}
- Internal: ${script.dependencies_internal.length > 0 ? script.dependencies_internal.join(", ") : "None"}

**Usage:**
\`\`\`bash
${runCommand}
\`\`\`

---
`;
}

function generateFolderReadme(
    folderPath: string,
    scripts: CategorizedScript[]
): string {
    const totalLoc = scripts.reduce((sum, s) => sum + s.lines_of_code, 0);
    const categories = [...new Set(scripts.map((s) => s.category))];

    let content = `# ๐“ Scripts: ${folderPath}

**Last Updated:** ${new Date().toISOString().split("T")[0]}  
**Total Scripts:** ${scripts.length}  
**Total Lines of Code:** ${totalLoc}  
**Categories:** ${categories.join(", ")}

## ๐“ Contents

`;

    for (const category of categories) {
        const categoryScripts = scripts.filter((s) => s.category === category);
        content += `
### ${category}
- **Count:** ${categoryScripts.length}
${categoryScripts.map((s) => `- ${s.filename}`).join("\n")}

`;
    }

    content += `## ๐“ Detailed Scripts

`;

    for (const script of scripts) {
        content += generateScriptEntry(script);
    }

    content += `
---
**Generated by Auto-Acct Code Scanner**  
**For:** Auto-Acct-001 (Bun + TypeScript)
`;

    return content;
}

async function generateDocs(): Promise<void> {
    const rootDir = process.cwd();
    const categPath = join(
        rootDir,
        "backend",
        "ANALYSIS",
        "SCRIPT_CATEGORIZATION.json"
    );

    try {
        const categContent = readFileSync(categPath, "utf-8");
        const allScripts: CategorizedScript[] = JSON.parse(categContent);

        // Group by folder
        // Group by folder using Inventory or derived paths
        const inventoryPath = join(
            rootDir,
            "backend",
            "ANALYSIS",
            "FOLDER_INVENTORY.json"
        );
        let folders: string[] = [];
        try {
            const inv = JSON.parse(readFileSync(inventoryPath, 'utf-8'));
            folders = inv.map((f: any) => f.path);
        } catch {
            folders = [
                "scripts",
                "backend/scripts",
                "backend/src/scripts",
                "backend/src/scripts/testing",
                "backend/src/scripts/maintenance",
                "backend/src/scripts/setup",
                "backend/src/scripts/tools",
                "backend/src/scripts/legacy"
            ];
        }

        for (const folderName of folders) {
            const folderScripts = allScripts.filter((s) =>
                s.path.replace(/\\/g, '/').startsWith(folderName)
            );

            if (folderScripts.length === 0) continue;

            const readmePath = join(rootDir, folderName, "README_SCRIPTS.md");
            mkdirSync(join(rootDir, folderName), { recursive: true });

            const readme = generateFolderReadme(folderName, folderScripts);
            writeFileSync(readmePath, readme);

            console.log(`โ… Generated: ${readmePath}`);
        }

        // Generate master summary
        const summaryPath = join(rootDir, "SCRIPTS_SUMMARY.md");
        let summary = `# ๐“ Auto-Acct Scripts Summary

**Generated:** ${new Date().toISOString()}  
**Total Scripts:** ${allScripts.length}

## ๐“ Statistics

| Category | Count | Subcategories |
|----------|-------|----------------|
`;

        const categories = [...new Set(allScripts.map((s) => s.category))];
        for (const cat of categories) {
            const catScripts = allScripts.filter((s) => s.category === cat);
            const subcats = [
                ...new Set(catScripts.map((s) => s.subcategory)),
            ];
            summary += `| ${cat} | ${catScripts.length} | ${subcats.join(", ")} |\n`;
        }

        summary += `
## ๐—๏ธ By Folder

`;

        for (const folder of folders) {
            const folderScripts = allScripts.filter((s) =>
                s.path.startsWith(folder)
            );
            if (folderScripts.length === 0) continue;

            summary += `### ${folder}\n`;
            summary += `- **Scripts:** ${folderScripts.length}\n`;
            summary += folderScripts.map((s) => `- ${s.filename}`).join("\n");
            summary += `\n\n`;
        }

        writeFileSync(summaryPath, summary);
        console.log(`\nโ… Master summary generated: ${summaryPath}`);
    } catch (err) {
        console.error("โ Error:", err);
    }
}

generateDocs().catch(console.error);
